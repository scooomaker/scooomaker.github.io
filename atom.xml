<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>scooo</title>
  
  <subtitle>Hello World</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-11T13:04:56.383Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>scooo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SwiftUI 控制流</title>
    <link href="http://example.com/2022/07/11/SwiftUI-%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <id>http://example.com/2022/07/11/SwiftUI-%E6%8E%A7%E5%88%B6%E6%B5%81/</id>
    <published>2022-07-11T11:04:23.000Z</published>
    <updated>2022-07-11T13:04:56.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="值绑定（Value-Bindings）"><a href="#值绑定（Value-Bindings）" class="headerlink" title="值绑定（Value Bindings）"></a>值绑定（Value Bindings）</h2><p>case 分支允许将匹配的值声明为临时常量或变量，并且在 case 分支体内使用 —— 这种行为被称为值绑定（value binding），因为匹配的值在 case 分支体内，与临时的常量或变量绑定。</p><p>下面的例子将下图中的点 (x, y)，使用 (Int, Int) 类型的元组表示，然后分类表示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint <span class="operator">=</span> (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the x-axis with an x value of <span class="subst">\(x)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the y-axis with a y value of <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“on the x-axis with an x value of 2”</span></span><br></pre></td></tr></table></figure><p><img src="https://docs.swift.org/swift-book/_images/coordinateGraphMedium_2x.png" alt="image"><br>在上面的例子中，switch 语句会判断某个点是否在红色的 x 轴上，是否在橘黄色的 y 轴上，或者不在坐标轴上。</p><p>这三个 case 都声明了常量 x 和 y 的占位符，用于临时获取元组 anotherPoint 的一个或两个值。第一个 case ——case (let x, 0) 将匹配一个纵坐标为 0 的点，并把这个点的横坐标赋给临时的常量 x。类似的，第二个 case ——case (0, let y) 将匹配一个横坐标为 0 的点，并把这个点的纵坐标赋给临时的常量 y。</p><p>一旦声明了这些临时的常量，它们就可以在其对应的 case 分支里使用。在这个例子中，它们用于打印给定点的类型。</p><p>请注意，这个 switch 语句不包含默认分支。这是因为最后一个 case ——case let(x, y) 声明了一个可以匹配余下所有值的元组。这使得 switch 语句已经完备了，因此不需要再书写默认分支。</p><h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>case 分支的模式可以使用 where 语句来判断额外的条件。</p><p>下面的例子把下图中的点 (x, y)进行了分类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint <span class="operator">=</span> (<span class="number">1</span>, <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“(1, -1) is on the line x == -y”</span></span><br></pre></td></tr></table></figure><p><strong>where同样适用于if语句</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;值绑定（Value-Bindings）&quot;&gt;&lt;a href=&quot;#值绑定（Value-Bindings）&quot; class=&quot;headerlink&quot; title=&quot;值绑定（Value Bindings）&quot;&gt;&lt;/a&gt;值绑定（Value Bindings）&lt;/h2&gt;&lt;p&gt;ca</summary>
      
    
    
    
    
    <category term="SwiftUI" scheme="http://example.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 集合</title>
    <link href="http://example.com/2022/07/11/SwiftUI-%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2022/07/11/SwiftUI-%E9%9B%86%E5%90%88/</id>
    <published>2022-07-11T11:04:14.000Z</published>
    <updated>2022-07-11T13:04:48.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。</p><p><img src="https://docs.swift.org/swift-book/_images/CollectionTypes_intro_2x.png" alt="image"></p><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><p>数组使用有序列表存储<strong>同一类型的多个值</strong>。相同的值可以多次出现在一个数组的不同位置中。</p><h4 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h4><p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInts is of type [Int] with <span class="subst">\(someInts.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“someInts is of type [Int] with 0 items.”</span></span><br></pre></td></tr></table></figure><p>注意，通过构造函数的类型，someInts 的值类型被推断为 [Int]。</p><p>或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：[]（一对空方括号）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someInts.append(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// someInts 现在包含一个 Int 值</span></span><br><span class="line">someInts <span class="operator">=</span> []</span><br><span class="line"><span class="comment">// someInts 现在是空数组，但是仍然是 [Int] 类型的。</span></span><br></pre></td></tr></table></figure><h4 id="创建一个带有默认值的数组"><a href="#创建一个带有默认值的数组" class="headerlink" title="创建一个带有默认值的数组"></a>创建一个带有默认值的数组</h4><p>Swift 中的 Array 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（count）和适当类型的初始值（repeating）传入数组构造函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure><h4 id="通过两个数组相加创建一个数组"><a href="#通过两个数组相加创建一个数组" class="headerlink" title="通过两个数组相加创建一个数组"></a>通过两个数组相加创建一个数组</h4><p>我们可以使用加法操作符（+）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherThreeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">2.5</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sixDoubles <span class="operator">=</span> threeDoubles <span class="operator">+</span> anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure><h4 id="用数组字面量构造数组"><a href="#用数组字面量构造数组" class="headerlink" title="用数组字面量构造数组"></a>用数组字面量构造数组</h4><p>我们可以使用数组字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。数组字面量是一系列由逗号分割并由方括号包含的数值：</p><p><code>[value 1, value 2, value 3]</code>。</p><p>下面这个例子创建了一个叫做 shoppingList 并且存储 String 的数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 已经被构造并且拥有两个初始项。</span></span><br></pre></td></tr></table></figure><p>shoppingList 变量被声明为“字符串值类型的数组“，记作 [String]。 因为这个数组被规定只有 String 一种数据结构，所以只有 String 类型可以在其中被存取。 在这里，shoppingList 数组由两个 String 值（”Eggs” 和 “Milk”）构造，并且由数组字面量定义。</p><blockquote><p>shoppingList 数组被声明为变量（var 关键字创建）而不是常量（let 创建）是因为以后可能会有更多的数据项被插入其中。</p></blockquote><p>在这个例子中，字面量仅仅包含两个 String 值。匹配了该数组的变量声明（只能包含 String 的数组），所以这个字面量的分配过程可以作为用两个初始项来构造 shoppingList 的一种方式。</p><p>由于 Swift 的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。shoppingList 的构造也可以这样写：</p><p><code>var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]</code><br>因为所有数组字面量中的值都是相同的类型，Swift 可以推断出 [String] 是 shoppingList 中变量的正确类型。</p><h3 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h3><p>集合（Set）用来存储<strong>相同类型并且没有确定顺序的值</strong>。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;集合类型&quot;&gt;&lt;a href=&quot;#集合类型&quot; class=&quot;headerlink&quot; title=&quot;集合类型&quot;&gt;&lt;/a&gt;集合类型&lt;/h1&gt;&lt;p&gt;Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型用来存储集合数据。数组（Arr</summary>
      
    
    
    
    
    <category term="SwiftUI" scheme="http://example.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 基础</title>
    <link href="http://example.com/2022/07/11/SwiftUI-%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/07/11/SwiftUI-%E5%9F%BA%E7%A1%80/</id>
    <published>2022-07-11T11:04:07.000Z</published>
    <updated>2022-07-11T13:08:16.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加号两边的数类型须相同"><a href="#加号两边的数类型须相同" class="headerlink" title="加号两边的数类型须相同"></a>加号两边的数类型须相同</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFiveNine <span class="operator">=</span> <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi <span class="operator">=</span> <span class="type">Double</span>(three) <span class="operator">+</span> pointOneFourOneFiveNine</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><code>typealias AudioSample = UInt16</code> </p><h2 id="元组（tuples）"><a href="#元组（tuples）" class="headerlink" title="元组（tuples）"></a>元组（tuples）</h2><p>把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error <span class="operator">=</span> (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="comment">// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</span></span><br></pre></td></tr></table></figure><p>将一个元组的内容分解（decompose）成单独的常量和变量</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) <span class="operator">=</span> http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(statusCode)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 404”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is <span class="subst">\(statusMessage)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status message is Not Found”</span></span><br></pre></td></tr></table></figure><p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="keyword">_</span>) <span class="operator">=</span> http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(justTheStatusCode)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 404”</span></span><br></pre></td></tr></table></figure><p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 404”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status message is Not Found”</span></span><br></pre></td></tr></table></figure><p>你可以在定义元组的时候给单个元素命名：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status <span class="operator">=</span> (statusCode: <span class="number">200</span>, description: <span class="string">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure><p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is <span class="subst">\(http200Status.statusCode)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status code is 200”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is <span class="subst">\(http200Status.description)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 输出“The status message is OK”</span></span><br></pre></td></tr></table></figure><h2 id="可选类型（optionals）"><a href="#可选类型（optionals）" class="headerlink" title="可选类型（optionals）"></a>可选类型（optionals）</h2><blockquote><p>nil 表示“缺少一个合法的对象”</p></blockquote><p>声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer 被自动设置为 nil</span></span><br></pre></td></tr></table></figure><p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;convertedNumber has an integer value of <span class="subst">\(convertedNumber<span class="operator">!</span>)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“convertedNumber has an integer value of 123.”</span></span><br></pre></td></tr></table></figure><h2 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h2><p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。if 和 while 语句，请参考 控制流。</p><p>像下面这样在 if 语句中写一个可选绑定：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName <span class="operator">=</span> someOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像上面这样使用可选绑定来重写 在 可选类型 举出的 possibleNumber 例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&#x27;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&#x27;</span> has an integer value of <span class="subst">\(actualNumber)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\&#x27;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&#x27;</span> could not be converted to an integer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“&#x27;123&#x27; has an integer value of 123”</span></span><br></pre></td></tr></table></figure><p>这段代码可以被理解为：</p><p>“如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。”</p><p>如果转换成功，actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用 ! 后缀来获取它的值。在这个例子中，actualNumber 只被用来输出转换结果。</p><p><strong>你可以在可选绑定中使用常量和变量</strong>。如果你想在 if 语句的第一个分支中操作 actualNumber 的值，你可以改成 if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。</p><p>你可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。<strong>只要有任意一个可选绑定的值为 nil，或者任意一个布尔条件为 false，则整个 if 条件判断为 false</strong>，这时你就需要使用嵌套 if 条件语句来处理，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>), firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“4 &lt; 42 &lt; 100”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出“4 &lt; 42 &lt; 100”</span></span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) <span class="operator">=</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 现在 x 等于 1，y 等于 2</span></span><br></pre></td></tr></table></figure><p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以下面语句是无效的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x <span class="operator">=</span> y &#123;</span><br><span class="line">    <span class="comment">// 此句错误，因为 x = y 并不返回任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过将 if x &#x3D; y 标记为无效语句，Swift 能帮你避免把 （&#x3D;&#x3D;）错写成（&#x3D;）这类错误的出现。</p><h2 id="空合运算符（Nil-Coalescing-Operator）"><a href="#空合运算符（Nil-Coalescing-Operator）" class="headerlink" title="空合运算符（Nil Coalescing Operator）"></a>空合运算符（Nil Coalescing Operator）</h2><p>空合运算符（a ?? b）将对可选类型 a 进行空判断，如果 a 包含一个值就进行解包，否则就返回一个默认值 b。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。</p><p>空合运算符是对以下代码的简短表达方法：</p><p><code>a != nil ? a! : b</code><br>上述代码使用了三元运算符。当可选类型 a 的值不为空时，进行强制解封（a!），访问 a 中的值；反之返回默认值 b。无疑空合运算符（??）提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具可读性。</p><p>注意</p><p>如果 a 为非空值（non-nil），那么值 b 将不会被计算。这也就是所谓的短路求值。</p><p>下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName <span class="operator">=</span> <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">//默认值为 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 &quot;red&quot;</span></span><br></pre></td></tr></table></figure><p>userDefinedColorName 变量被定义为一个可选的 String 类型，默认值为 nil。由于 userDefinedColorName 是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为 colorNameToUse 的变量赋予一个字符串类型初始值。 由于 userDefinedColorName 值为空，因此表达式 userDefinedColorName ?? defaultColorName 返回 defaultColorName 的值，即 red。</p><p>如果你分配一个非空值（non-nil）给 userDefinedColorName，再次执行空合运算，运算结果为封包在 userDefaultColorName 中的值，而非默认值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userDefinedColorName <span class="operator">=</span> <span class="string">&quot;green&quot;</span></span><br><span class="line">colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 非空，因此 colorNameToUse 的值为 &quot;green&quot;</span></span><br></pre></td></tr></table></figure><h2 id="区间运算符（Range-Operators）"><a href="#区间运算符（Range-Operators）" class="headerlink" title="区间运算符（Range Operators）"></a>区间运算符（Range Operators）</h2><h4 id="闭区间运算符"><a href="#闭区间运算符" class="headerlink" title="闭区间运算符"></a>闭区间运算符</h4><p><strong>闭区间运算符（a…b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。a 的值不能超过 b</strong>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(index)</span> * 5 = <span class="subst">\(index <span class="operator">*</span> <span class="number">5</span>)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure><h4 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h4><p><strong>半开区间运算符（a..&lt;b）定义一个从 a 到 b 但不包括 b 的区间。</strong></p><p><em>半开区间的实用性在于当你使用一个从 0 开始的列表（如数组）时，非常方便地从0数到列表的长度。</em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> count <span class="operator">=</span> names.count</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>count &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第 <span class="subst">\(i <span class="operator">+</span> <span class="number">1</span>)</span> 个人叫 <span class="subst">\(names[i])</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 1 个人叫 Anna</span></span><br><span class="line"><span class="comment">// 第 2 个人叫 Alex</span></span><br><span class="line"><span class="comment">// 第 3 个人叫 Brian</span></span><br><span class="line"><span class="comment">// 第 4 个人叫 Jack</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;加号两边的数类型须相同&quot;&gt;&lt;a href=&quot;#加号两边的数类型须相同&quot; class=&quot;headerlink&quot; title=&quot;加号两边的数类型须相同&quot;&gt;&lt;/a&gt;加号两边的数类型须相同&lt;/h3&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="SwiftUI" scheme="http://example.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to ROS</title>
    <link href="http://example.com/2022/07/10/Introduction-to-ROS/"/>
    <id>http://example.com/2022/07/10/Introduction-to-ROS/</id>
    <published>2022-07-10T15:58:45.000Z</published>
    <updated>2022-07-10T16:06:17.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>　　　　ROS可以形象的描述为一个工厂的运行机制，创建好一个工作空间(workspace)就像一个工厂，工厂里又有好多个生产车间，每个功能包（pkg）看作是一个生产车间，每个生产车间又有好多工人在配合，每个节点（node）看作是一个工人，节点是又是可执行程序的最小单位，工人们之间相互沟通通过消息（mesage）来完成.</p></blockquote><h3 id="ROS-Master-节点管理器"><a href="#ROS-Master-节点管理器" class="headerlink" title="ROS Master 节点管理器"></a>ROS Master 节点管理器</h3><p><img src="https://img-blog.csdnimg.cn/20200729170450220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pha2VYWQ==,size_16,color_FFFFFF,t_70" alt="ROS Master"></p><ul><li>节点将所有信息发送给ROS Master</li><li>发送信息的节点称为发布节点(Publisher Nodes)</li><li>接收信息的节点称为订阅节点(Subscriber Nodes)</li><li>ROS Master拥有在计算机上正在运行的所有发送节点和接收节点的信息.</li></ul><p>例如: 节点1发送给某个名为a的数据,而节点2订阅了该消息,那么ROS Masker就向两个节点广播彼此节点信息,以帮助他们建立连接,这样两个节点就能互相通信了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p>输入这个命令来开启 ROS Master</p><h3 id="ROS-Messages-通信架构"><a href="#ROS-Messages-通信架构" class="headerlink" title="ROS Messages 通信架构"></a>ROS Messages 通信架构</h3><p>ROS节点可以彼此间互相传送不同数据类型,这些数据称为ROS消息(ROS Messages).有了ROS Messages就能在节点之间传递各种类型的数据了.这些消息通过一种类似于数据总线或者路径标识的媒介进行传播,称为ROS话题(Topics).</p><h4 id="话题（topic）"><a href="#话题（topic）" class="headerlink" title="话题（topic）"></a>话题（topic）</h4><p>　　话题是单向的，一般用于连续发送数据的传感器，建立一次联系后，一个发布者可以向多个订阅者发送信息，同样，一个订阅者也可以订阅多个发布者的消息。对于实时性、周期性的消息，使用topic来传输是最佳的选择。</p><blockquote><p>topic通信方式是异步的，发送时调用publish()方法，发送完成立即返回，不用等待反馈。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200729170511683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pha2VYWQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>几种topic命令:</p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>rostopic list</code></td><td align="left">列出当前所有的topic</td></tr><tr><td align="left"><code>rostopic info topic_name</code></td><td align="left">显示某个topic的属性信息</td></tr><tr><td align="left"><code>rostopic echo topic_name</code></td><td align="left">显示某个topic的内容</td></tr><tr><td align="left"><code>rostopic pub topic_name ...</code></td><td align="left">向某个topic发布内容</td></tr><tr><td align="left"><code>rostopic bw topic_name</code></td><td align="left">查看某个topic的带宽</td></tr><tr><td align="left"><code>rostopic hz topic_name</code></td><td align="left">查看某个topic的频率</td></tr><tr><td align="left"><code>rostopic find topic_type</code></td><td align="left">查找某个类型的topic</td></tr><tr><td align="left"><code>rostopic type topic_name</code></td><td align="left">查看某个topic的类型(msg)</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200729170522144.png" alt="在这里插入图片描述"></p><h4 id="服务（service）"><a href="#服务（service）" class="headerlink" title="服务（service）"></a>服务（service）</h4><p>　　服务是同步双向的通信机制，服务器只有在有请求的时候才响应，客户端在发出请求后才接受响应。service包括两部分，一部分是请求方（Clinet），另一部分是应答方&#x2F;服务提供方（Server）。当服务的请求和响应完成时，两个连接点自动断开。</p><blockquote><p>Service是同步通信方式，所谓同步就是说，此时Node A发布请求后会在原地等待reply，直到Node B处理完了请求并且完成了reply，Node A才会继续执行。Node A等待过程中，是处于阻塞状态的成通信。这样的通信模型没有频繁的消息传递，没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200729170536455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pha2VYWQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>几种service命令:</p><table><thead><tr><th align="left">rosservice 命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>rosservice list</code></td><td align="left">显示服务列表</td></tr><tr><td align="left"><code>rosservice info</code></td><td align="left">打印服务信息</td></tr><tr><td align="left"><code>rosservice type</code></td><td align="left">打印服务类型</td></tr><tr><td align="left"><code>rosservice uri</code></td><td align="left">打印服务ROSRPC uri</td></tr><tr><td align="left"><code>rosservice find</code></td><td align="left">按服务类型查找服务</td></tr><tr><td align="left"><code>rosservice call</code></td><td align="left">使用所提供的args调用服务</td></tr><tr><td align="left"><code>rosservice args</code></td><td align="left">打印服务参数</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200729170549247.png" alt="在这里插入图片描述"></p><h4 id="Topic和Service对比"><a href="#Topic和Service对比" class="headerlink" title="Topic和Service对比"></a>Topic和Service对比</h4><table><thead><tr><th align="left">名称</th><th align="left">Topic</th><th align="left">Service</th></tr></thead><tbody><tr><td align="left">通信方式</td><td align="left">异步通信</td><td align="left">同步通信</td></tr><tr><td align="left">实现原理</td><td align="left">TCP&#x2F;IP</td><td align="left">TCP&#x2F;IP</td></tr><tr><td align="left">通信模型</td><td align="left">Publish-Subscribe</td><td align="left">Request-Reply</td></tr><tr><td align="left">映射关系</td><td align="left">Publish-Subscribe(多对多)</td><td align="left">Request-Reply（多对一）</td></tr><tr><td align="left">特点</td><td align="left">接受者收到数据会回调（Callback）</td><td align="left">远程过程调用（RPC）服务器端的服务</td></tr><tr><td align="left">应用场景</td><td align="left">连续、高频的数据发布</td><td align="left">偶尔使用的功能&#x2F;具体的任务</td></tr><tr><td align="left">举例</td><td align="left">激光雷达、里程计发布数据</td><td align="left">开关传感器、拍照、逆解计算</td></tr></tbody></table><h4 id="动作（Action）"><a href="#动作（Action）" class="headerlink" title="动作（Action）"></a>动作（Action）</h4><p>　　Actionlib库类似service通信机制，actionlib也是一种请求响应机制的通信方式，actionlib主要弥补了service通信的一个不足，就是当机器人执行一个长时间的任务时，假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，致使通信受阻。当service通信不能很好的完成任务时候，actionlib则可以比较适合实现长时间的通信过程，actionlib通信过程可以随时被查看过程进度，也可以终止请求，这样的一个特性，使得它在一些特别的机制中拥有很高的效率。</p><blockquote><p>Action的工作原理是client-server模式，也是一个双向的通信模式。通信双方在ROS Action Protocol下通过消息进行数据的交流通信。client和server为用户提供一个简单的API来请求目标（在客户端）或通过函数调用和回调来执行目标（在服务器端）。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200729170600800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pha2VYWQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>利用动作库进行请求响应，动作的内容格式应包含三个部分，目标、反馈、结果。</p><ul><li><p>目标</p><p>机器人执行一个动作，应该有明确的移动目标信息，包括一些参数的设定，方向、角度、速度等等。从而使机器人完成动作任务。</p></li><li><p>反馈</p><p>在动作进行的过程中，应该有实时的状态信息反馈给服务器的实施者，告诉实施者动作完成的状态，可以使实施者作出准确的判断去修正命令。</p></li><li><p>结果</p><p>当运动完成时，动作服务器把本次运动的结果数据发送给客户端，使客户端得到本次动作的全部信息，例如可能包含机器人的运动时长，最终姿势等等。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200729170611147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pha2VYWQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;　　　　ROS可以形象的描述为一个工厂的运行机制，创建好一个工作空间(workspace)就像一个工厂，工厂里又有好多个生产车间，每个功能包（pkg）看作是一个生产车间，每个生产车间又有好多工人在配合，每个节点（node）看作是一个工人，节点是又是</summary>
      
    
    
    
    
    <category term="ROS" scheme="http://example.com/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>VScode &amp;&amp; Arduino FAQs</title>
    <link href="http://example.com/2022/07/10/VScode-Arduino-FAQs/"/>
    <id>http://example.com/2022/07/10/VScode-Arduino-FAQs/</id>
    <published>2022-07-10T11:57:30.000Z</published>
    <updated>2022-07-10T16:02:27.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用VScode开发Arduino"><a href="#使用VScode开发Arduino" class="headerlink" title="使用VScode开发Arduino"></a>使用VScode开发Arduino</h1><p>在VScode中开发Arduino ，会出现<font color="#dd0000">  <strong>#include</strong>出现红色下划线</font></p><p>1.安装arduino1.8.7，1.8.7以上编译会乱码<br>2.用vscode打开一个空文件夹，新建xxx.ino文件，ino文件名和文件夹名相同;<br>3.在右下方选择好开发板后,在”.vscode”文件夹中添加：    <strong>settings.json</strong>。</p><p>打开settings.json写入:</p><p><strong>settings.json:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;C_Cpp.errorSquiggles&quot;</span>:<span class="string">&quot;Disabled&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成:<img src="https://img-blog.csdnimg.cn/20200331160532548.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pha2VYWQ==,size_16,color_FFFFFF,t_70#pic_center" alt="完成"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用VScode开发Arduino&quot;&gt;&lt;a href=&quot;#使用VScode开发Arduino&quot; class=&quot;headerlink&quot; title=&quot;使用VScode开发Arduino&quot;&gt;&lt;/a&gt;使用VScode开发Arduino&lt;/h1&gt;&lt;p&gt;在VScode中开发</summary>
      
    
    
    
    
    <category term="FAQs" scheme="http://example.com/tags/FAQs/"/>
    
  </entry>
  
  <entry>
    <title>Hexo FAQs</title>
    <link href="http://example.com/2022/07/10/Hexo-FAQs/"/>
    <id>http://example.com/2022/07/10/Hexo-FAQs/</id>
    <published>2022-07-10T10:55:25.000Z</published>
    <updated>2022-07-10T11:58:04.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-FAQs"><a href="#Hexo-FAQs" class="headerlink" title="Hexo FAQs"></a>Hexo FAQs</h1><h3 id="1安装nodejs后在命令行运行npm报错"><a href="#1安装nodejs后在命令行运行npm报错" class="headerlink" title="1安装nodejs后在命令行运行npm报错"></a>1安装nodejs后在命令行运行npm报错</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Error: Cannot find module &#x27; internal/util/types&#x27;</span><br><span class="line">at Function. Module._resolveFilename (module. js:536:15)</span><br><span class="line">at Function. Module._load 〈 module. js:466:25)</span><br><span class="line">at Module. require (module. js:579:17)</span><br><span class="line">at require 〈 internal/module. js:11:18)</span><br><span class="line">at evalmachine.&lt;anonymous&gt;:31:26</span><br><span class="line">at Object.&lt;anonymous&gt;(C: Users \w1s003\ AppData \ Roaning\ npm\ node _nodules\ npm node_modules\ graceful-fs\ fs. js:11:1)</span><br><span class="line">at Module._compile (module. js:635:30)</span><br><span class="line">at Object. Module._extensions.. js (module. js:646:10)</span><br><span class="line">at Module. load(module. js:554:32)</span><br><span class="line">at tryModuleLoad〈 module. js:497:12)</span><br></pre></td></tr></table></figure><p>解决方法：删除目录“C:\Users&lt;user&gt;\AppData\Roaming\npm\node_modules”下的npm文件夹</p><h3 id="2-如何安装最新版本Hexo"><a href="#2-如何安装最新版本Hexo" class="headerlink" title="2.如何安装最新版本Hexo"></a>2.如何安装最新版本Hexo</h3><p>如果要查看hexo的版本，请先建立一个空目录，执行<code>hexo init</code>命令，运行完毕后在终端输入<code>hexo -v</code>来查看hexo版本，否则你只能看到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: Linux 5.4.0-62-generic linux x64</span><br><span class="line">node: 12.18.3</span><br><span class="line">v8: 7.8.279.23-node.39</span><br><span class="line">uv: 1.38.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.16.0</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 6</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">http_parser: 2.9.3</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure><p>下载最新版，如果<code>hexo init</code>时网速太慢，可以直接从github上下载下来，地址：<a href="https://github.com/hexojs/hexo/releases"><strong>https://github.com/hexojs/hexo/releases</strong></a></p><p>目前更新到6.2.0版本</p><p>找到C盘下的<code>node_modules</code>文件夹里的<code>hexo-cli</code> 具体位置为：C:\Users&lt;user&gt;\AppData\Roaming\npm\node_modules\hexo-cli</p><p>替换官网下载的文件</p><p>然后打开终端，输入<code>hexo -v</code>，这时会报错，只需运行按照提示运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules &amp;&amp; npm install --force</span><br></pre></td></tr></table></figure><p>成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">INFO  Validating config</span><br><span class="line">hexo: 6.2.0</span><br><span class="line">hexo-cli: 6.2.0</span><br><span class="line">os: win32 10.0.22000</span><br><span class="line">node: 16.15.1</span><br><span class="line">v8: 9.4.146.24-node.21</span><br><span class="line">uv: 1.43.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.18.1</span><br><span class="line">modules: 93</span><br><span class="line">nghttp2: 1.47.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 6.0.4</span><br><span class="line">openssl: 1.1.1o+quic</span><br><span class="line">cldr: 40.0</span><br><span class="line">icu: 70.1</span><br><span class="line">tz: 2021a3</span><br><span class="line">unicode: 14.0</span><br><span class="line">ngtcp2: 0.1.0-DEV</span><br><span class="line">nghttp3: 0.1.0-DEV</span><br></pre></td></tr></table></figure><h3 id="3绑定域名后出现GitHub-Pages-404错误"><a href="#3绑定域名后出现GitHub-Pages-404错误" class="headerlink" title="3绑定域名后出现GitHub Pages 404错误"></a>3绑定域名后出现GitHub Pages 404错误</h3><p>打开Github，找到存储库的settings-&gt;Pages-&gt;Custom domain 检查域名是否空白，检查域名控制台。</p><h3 id="4主题优化及其他"><a href="#4主题优化及其他" class="headerlink" title="4主题优化及其他"></a>4主题优化及其他</h3><p><a href="https://www.jianshu.com/p/043a4ae7684d">主题优化</a> <a href="https://imgtu.com/">免费图床</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-FAQs&quot;&gt;&lt;a href=&quot;#Hexo-FAQs&quot; class=&quot;headerlink&quot; title=&quot;Hexo FAQs&quot;&gt;&lt;/a&gt;Hexo FAQs&lt;/h1&gt;&lt;h3 id=&quot;1安装nodejs后在命令行运行npm报错&quot;&gt;&lt;a href=&quot;#1安装n</summary>
      
    
    
    
    
    <category term="FAQs" scheme="http://example.com/tags/FAQs/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/07/08/hello-world/"/>
    <id>http://example.com/2022/07/08/hello-world/</id>
    <published>2022-07-08T14:42:11.849Z</published>
    <updated>2022-07-08T14:42:11.849Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
